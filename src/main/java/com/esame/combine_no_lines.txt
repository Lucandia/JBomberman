package com.esame;
public class App {
    
    public static void main(String[] args) {
        MainMenu.main(args);
    }
}
package com.esame;
import javafx.scene.media.AudioClip;
import java.net.URL;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.HashSet;
public class AudioUtils {
    private static Set<AudioClip> playingClips = new HashSet<>();
    private static final Map<String, AudioClip> clips = new HashMap<>();
    public static void preloadSoundEffect(String audioFileName) {
        URL soundEffectUrl = AudioUtils.class.getResource("/audio/" + audioFileName);
        if (soundEffectUrl != null) {
            AudioClip clip = new AudioClip(soundEffectUrl.toString());
            clips.put(audioFileName, clip);
        } else {
            System.err.println("Impossibile caricare in memoria il file audio: " + audioFileName);
        }
    }
    public static void playSoundEffect(String audioFileName) {
        AudioClip clip = clips.get(audioFileName);
        if (clip != null) {
            clip.play();
            playingClips.add(clip);
        } else {
            System.err.println("Effetto sonoro non caricato in memoria: " + audioFileName);
        }
        playingClips.removeIf(oldclip -> !oldclip.isPlaying());
    }
    public static void stopAll() {
        playingClips.forEach(AudioClip::stop);
        playingClips.clear();
    }
    public static void preloadAll() {
        preloadSoundEffect("BombExplodes.mp3");
        preloadSoundEffect("GameOver.mp3");
        preloadSoundEffect("ItemGet.mp3");
        preloadSoundEffect("LoseLife.mp3");
        preloadSoundEffect("MainMenu.mp3");
        preloadSoundEffect("PlaceBomb.mp3");
        preloadSoundEffect("StageClear.mp3");
        preloadSoundEffect("StageStart.mp3");
        preloadSoundEffect("Walking.mp3");
    }
}
package com.esame;
import javafx.scene.media.Media;
import javafx.scene.media.MediaPlayer;
import java.net.URL;
public class BackgroundMusic {
    private MediaPlayer mediaPlayer;
    public void playMusic(String audioFileName) {
        try {
            // Carica il file audio
            URL musicFileUrl = getClass().getResource("/audio/" + audioFileName);
            if (musicFileUrl != null) {
                Media media = new Media(musicFileUrl.toExternalForm());
                mediaPlayer = new MediaPlayer(media);
                mediaPlayer.setOnEndOfMedia(new Runnable() {
                    @Override
                    public void run() {
                        mediaPlayer.seek(javafx.util.Duration.ZERO); // Torna all'inizio
                    }
                });
                mediaPlayer.play();
                mediaPlayer.setVolume(0.7);
            } else {
                System.err.println("Impossibile trovare il file audio: " + audioFileName);
            }
        } catch (Exception e) {
            e.printStackTrace();
            System.err.println("Errore durante la riproduzione del file audio.");
        }
    }
    public void stopMusic() {
        if (mediaPlayer != null) {
            mediaPlayer.stop();
        }
    }
}
package com.esame;
import java.util.List;
import java.util.ArrayList;
import javafx.scene.layout.Pane;
import javafx.beans.property.IntegerProperty;
import javafx.beans.property.SimpleIntegerProperty;
public class BombController {
    
    private List<BombModel> bombList = new ArrayList<>();
    private Pane pane;
    private StageModel stage;
    private IntegerProperty currentX = new SimpleIntegerProperty();
    private IntegerProperty currentY = new SimpleIntegerProperty();
    private IntegerProperty maxBombs = new SimpleIntegerProperty();
    private IntegerProperty bombRadius = new SimpleIntegerProperty();
    public BombController(PlayerModel playerModel, Pane pane) {
        currentX.bind(playerModel.centerXProperty());
        currentY.bind(playerModel.centerYProperty());
        maxBombs.bind(playerModel.bombCapacityProperty());
        bombRadius.bind(playerModel.bombRadiusProperty());
        this.pane = pane;
        this.stage = playerModel.getStage();
    }
    
    public void input() {
        if (bombList.size() < maxBombs.get()) {
            int[] startPosition = stage.getTileStartCoordinates(currentX.get(), currentY.get());
            if (stage.addBombAtPosition(startPosition[0], startPosition[1], bombRadius.get())) {
                AudioUtils.playSoundEffect("PlaceBomb.mp3");
                BombModel bomb = stage.getBombAtPosition(startPosition[0], startPosition[1]);
                BombView bombView = new BombView(pane, stage.getTileSize());
                bomb.addListener(bombView);
                bombList.add(bomb);
            }
        }
    }
    public boolean destroyLimit(BombModel bomb, int x, int y) {
        // uso le stringe perche' se uso int[], equals non funziona bene (cerca il riferimento)
        Tile tile = stage.getTile(x, y);
        if (tile == null) return true; // Tile is out of bounds
        // the tile is destructible
        else if (!tile.isDestructible()) {
            return true;
        }
        else if (tile.isDetonable()) {
            bomb.addDetonatePosition(x, y);
            if (tile instanceof BombModel) {
                // Se la bomba e' gia' stata esaminata, non la esplodo
                DetonateBomb((BombModel) tile);
                return true;
            }
            else {
                stage.destroyTile(x, y);
                return true;
            }
        }
        bomb.addDetonatePosition(x, y);
        return false;
    }
    public void DetonateBomb(BombModel bomb) {
        AudioUtils.playSoundEffect("BombExplodes.mp3");
        int blast = bomb.getBlastRadius();
        int tileX = (int) bomb.getX() / stage.getTileSize();
        int tileY = (int) bomb.getY() / stage.getTileSize();
        stage.destroyTile(tileX, tileY);
        for (int x = -1; x >= -blast; x--) {
            if (destroyLimit(bomb, tileX + x, tileY)) break;
        }
        for (int x = 1; x <= blast; x++) {
            if (destroyLimit(bomb, tileX + x, tileY)) break;
        }
        for (int y = -1; y >= -blast; y--) {
            if (destroyLimit(bomb, tileX, tileY + y)) break;
        }
        for (int y = 1; y <= blast; y++) {
            if (destroyLimit(bomb, tileX, tileY + y)) break;
        }
        bomb.explode();
    }
    public void updateState(double elapsed) {
        // Update all bombs
        bombList.forEach(bomb -> bomb.updateState(elapsed));
        // Detonate bombs that not active anymore
        bombList.stream()
            .filter(bomb -> !bomb.isActive())
            .forEach(bomb -> DetonateBomb(bomb));
        // Remove inactive bombs
        bombList.removeIf(bomb -> !bomb.isActive());
    }
}
package com.esame;
import javafx.beans.property.SimpleBooleanProperty;
import javafx.beans.InvalidationListener;
import javafx.beans.Observable;
import javafx.beans.property.BooleanProperty;
import java.util.ArrayList;
import java.util.List;
public class BombModel extends EmptyTile implements Observable{
    /*
    * La lista delle BombViews che osservano il modello observer della classe.
    private List<BombView> observers = new ArrayList<>();
    private List<String> detonatePositions = new ArrayList<>();
    private int blastRadius = 1; // Default blast radius
    private BooleanProperty active = new SimpleBooleanProperty(true); // Bomb is active by default  
    private final double totalTime = 3; // Bomb timer in seconds
    private double timer = totalTime; // Bomb timer in seconds
    private double walkableTime = totalTime / 5; // time on which you can walk on the bomb
    public BombModel(int x, int y, int radius) {
        super(x, y);
        blastRadius = radius;
    }
    public BombModel(int x, int y, int radius, double time) {
        super(x, y);
        blastRadius = radius;
        time = timer;
    }
    public boolean isDetonable() {
        return true;
    }
    public int getBlastRadius() {
        return blastRadius;
    }
    public BooleanProperty activeProperty() {
        return active;
    }
    public boolean isActive() {
        return active.get();
    }
    public void explode() {
        active.set(false);
        setTimer(0);
        notifyListeners();
    }
    public double getTimer() {
        return timer;
    }
    public void setTimer(double time) {
        timer = time;
    }
    public double getTotalTime() {
        return totalTime;
    }
    public List<String> getDetonatePositions() {
        return detonatePositions;
    }
    public void addDetonatePosition(int x, int y) {
        detonatePositions.add(x + "," + y);
    }
    public boolean containsDetonatePosition(int x, int y) {
        return detonatePositions.contains(x + "," + y);
    }
    
    public void addListener(InvalidationListener observer) {
        observers.add((BombView) observer);
    }
    public void removeListener(InvalidationListener observer) {
        observers.remove((BombView) observer);
    }
    public void notifyListeners() {
        for (BombView observer : observers) {
            observer.update(this);
        }
    }
    public void updateState(double elapsed) {
        notifyListeners();
        if (isActive()) {
            timer -= elapsed;
            walkableTime -= elapsed;
            if (walkableTime <= 0) {
                setWalkable(false);
            }
            if (timer <= 0) {
                // Bomb should explode
                explode();
            }
        }
        notifyListeners();
    }
}
package com.esame;
import javafx.beans.InvalidationListener;
public interface BombObserver extends InvalidationListener{
    
    void update(BombModel bombModel);
}
package com.esame;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.layout.Pane;
import javafx.util.Duration;
import java.util.ArrayList;
import java.util.List;
import javafx.beans.Observable;
import javafx.animation.Animation;
import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.geometry.Rectangle2D;
// import javafx.beans.Observable;
// import javafx.beans.property.SimpleBooleanProperty;
// import javafx.beans.property.BooleanProperty;
public class BombView implements BombObserver{
    private ImageView bombSprite;
    private Timeline bombAnimation = null;
    private int size;
    private Pane pane;
    private boolean activated = false;
    public BombView(Pane pane, int size) {
        this.pane = pane;
        this.size = size;
        // Assuming the sprite sheet is in the same package as the BombView
        Image image = new Image(getClass().getResourceAsStream("/sprites/bomb.png"));
        bombSprite = new ImageView(image);
        // Set the initial viewport to show the first sprite
        bombSprite.setViewport(new Rectangle2D(0, 0, 16, 16));
        // active.bind(bombModel.activeProperty());
        // // Bind the ImageView's position to the model's position
        // bombSprite.layoutXProperty().set(bombModel.getX());
        // bombSprite.layoutYProperty().set(bombModel.getY());
    }
    public void startBombAnimation(BombModel bomb) {
        double totalTime = bomb.getTotalTime();
        // Animation timer to cycle through the sprites
        double frameTime = totalTime / 10; // Time to cycle through all sprites
        bombAnimation = new Timeline(
            new KeyFrame(Duration.seconds(0), e -> bombSprite.setViewport(new Rectangle2D(0, 0, 16, 16))),
            new KeyFrame(Duration.seconds(frameTime * 2), e -> bombSprite.setViewport(new Rectangle2D(17, 0, 16, 16))),
            new KeyFrame(Duration.seconds(frameTime * 3), e -> bombSprite.setViewport(new Rectangle2D(34, 0, 16, 16)))
        );
        bombSprite.layoutXProperty().set(bomb.getX());
        bombSprite.layoutYProperty().set(bomb.getY());
        bombAnimation.setCycleCount(Animation.INDEFINITE);
        bombAnimation.setAutoReverse(true);
        bombAnimation.play();
        addToPane();
    }
    public void playExplosionAnimation(BombModel model) { 
        int radius = model.getBlastRadius();
        Image explosionImage = new Image(getClass().getResourceAsStream("/sprites/explosion.png"));
        // List to hold all explosion sprites
        List<ImageView> explosionSprites = new ArrayList<>();
        // Assuming the bomb is placed in the center of the tile
        int bombX = (int) bombSprite.layoutXProperty().get();
        int bombY = (int) bombSprite.layoutYProperty().get();
        int tileX = (int) bombX / size;
        int tileY = (int) bombY / size;
        // Generate explosion at the bomb position
        ImageView mainExplosionSprite = new ImageView(explosionImage);
        mainExplosionSprite.setViewport(new Rectangle2D(32, 32, size, size)); // Set to the initial frame
        mainExplosionSprite.layoutXProperty().set(bombX); // Centering the explosion sprite
        mainExplosionSprite.layoutYProperty().set(bombY);
        explosionSprites.add(mainExplosionSprite);
        pane.getChildren().add(mainExplosionSprite);
        // Generate explosion on the positive x axis
        int max_dx = radius;
        for (int dx = 1; dx <= radius; dx++) {
            if (model.containsDetonatePosition(tileX + dx, tileY)) {
                // Check the explosion to display
                if (!model.containsDetonatePosition(tileX + dx + 1, tileY)) {
                    max_dx = dx;
                }
                    ImageView explosionSprite = new ImageView(explosionImage);
                    int rect_x = 3;
                    int rect_y = 2;
                    if (dx == max_dx) {
                        rect_x = 4;
                    }
                    explosionSprite.setViewport(new Rectangle2D(rect_x * size, rect_y * size, size, size)); // Set to the initial frame
                    explosionSprite.layoutXProperty().set(bombX + dx * size); // Centering the explosion sprite
                    explosionSprite.layoutYProperty().set(bombY);
                    explosionSprites.add(explosionSprite);
                    pane.getChildren().add(explosionSprite);
                }
            else break;
            if (dx == max_dx) break;
        }
        // Generate explosion on the negative x axis
        int min_dx = -radius;
        for (int dx = -1; dx >= -radius; dx--) {
            // Check the explosion to display
            if (model.containsDetonatePosition(tileX + dx, tileY)) {
                if (!model.containsDetonatePosition(tileX + dx - 1, tileY)) {
                    min_dx = dx;
                }
                ImageView explosionSprite = new ImageView(explosionImage);
                int rect_x = 1;
                int rect_y = 2;
                if (dx == min_dx) {
                    rect_x = 0;
                }
                explosionSprite.setViewport(new Rectangle2D(rect_x * size, rect_y * size, size, size)); // Set to the initial frame
                explosionSprite.layoutXProperty().set(bombX + dx * size); // Centering the explosion sprite
                explosionSprite.layoutYProperty().set(bombY);
                explosionSprites.add(explosionSprite);
                pane.getChildren().add(explosionSprite);
            }
            else break;
            if (dx == min_dx) break;
        }
        // Generate explosion on the positive y axis
        int max_dy = radius;
        for (int dy = 1; dy <= radius; dy++) {
            // Check the explosion to display
            if (model.containsDetonatePosition(tileX, tileY + dy)) {
                if (!model.containsDetonatePosition(tileX, tileY + dy + 1)) {
                    max_dy = dy;
                }
                ImageView explosionSprite = new ImageView(explosionImage);
                int rect_x = 2;
                int rect_y = 3;
                if (dy == max_dy) {
                    rect_y = 4;
                }
                explosionSprite.setViewport(new Rectangle2D(rect_x * size, rect_y * size, size, size)); // Set to the initial frame
                explosionSprite.layoutXProperty().set(bombX); // Centering the explosion sprite
                explosionSprite.layoutYProperty().set(bombY + dy * size);
                explosionSprites.add(explosionSprite);
                pane.getChildren().add(explosionSprite);
            }
            else break;
            if (dy == max_dy) break;
        }
        // Generate explosion on the negative y axis
        int min_dy = -radius;
        for (int dy = -1; dy >= -radius; dy--) {
            // Check the explosion to display
            if (model.containsDetonatePosition(tileX, tileY + dy)) {
                if (!model.containsDetonatePosition(tileX, tileY + dy - 1)){
                    min_dy = dy;
                }
                ImageView explosionSprite = new ImageView(explosionImage);
                int rect_x = 2;
                int rect_y = 1;
                if (dy == min_dy) {
                    rect_y = 0;
                }
                explosionSprite.setViewport(new Rectangle2D(rect_x * size, rect_y * size, size, size)); // Set to the initial frame
                explosionSprite.layoutXProperty().set(bombX); // Centering the explosion sprite
                explosionSprite.layoutYProperty().set(bombY + dy * size);
                explosionSprites.add(explosionSprite);
                pane.getChildren().add(explosionSprite);
            }
            else break;
            if (dy == min_dy) break;
        }
    
        double frameTime = model.getTotalTime() / 25; // Time between each frame of the explosion animation
        // Create and play the explosion animation
        Timeline explosionAnimation = new Timeline();
        for (int frameIndex = 0; frameIndex < 5; frameIndex++) { // For each frame of the explosion
            final int index = frameIndex;
            explosionAnimation.getKeyFrames().add(new KeyFrame(Duration.seconds(index * frameTime), e -> {
                for (ImageView sprite : explosionSprites) {
                    Rectangle2D viewport = sprite.getViewport();
                    sprite.setViewport(new Rectangle2D(viewport.getMinX() + 16 * 5 * index, viewport.getMinY(), size, size));
                }
            }));
        }
        explosionAnimation.setOnFinished(e -> explosionSprites.forEach(sprite -> pane.getChildren().remove(sprite))); // Remove sprites after animation
        explosionAnimation.play();
    }
    
    public ImageView getbombSprite() {
        return bombSprite;
    }
    public void addToPane() {
        pane.getChildren().add(getbombSprite());
    }
    @Override
    public void invalidated(Observable observable) {
        // Update the ImageView's position to match the model's position
        pane.getChildren().remove(bombSprite);
    }
    public void update(BombModel model) {
        // Controllo se la bomba è attiva
        if (!model.isActive()) {
            // se non e' attiva, esplodo la bomba
            playExplosionAnimation(model);
            pane.getChildren().remove(bombSprite);
            }
        // se la bomba e' attiva e non e' stata attivata, inizio l'animazione della bomba
        else if (!activated) {
            activated = true;
            startBombAnimation(model);
        }
    }
}
package com.esame;
public class EmptyTile extends Tile{
    /*
     * Il modello dell'entità che occupa la casella.
    private EntityModel occupant = null;
    public EmptyTile(int x, int y) {
        super(x, y, true, false, true);
    }
    public boolean isOccupied() {
        return occupant != null;
    }
    public boolean isDetonable() {
        return isOccupied();
    }
    public EntityModel getOccupant() {
        return occupant;
    }
    public void setOccupant(EntityModel occupant) {
        this.occupant = occupant;
    }
}package com.esame;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Random;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import javafx.scene.layout.Pane;
public class EnemiesController {
    private List<EnemyModel> enemies = new ArrayList<EnemyModel>();
    public EnemiesController(int numberOfEnemies, StageModel stageModel, Pane gameLayer, int level) {
        List<int[]> freeTileIndex = stageModel.getFreeTileIndex();
        Random random = new Random();
        int i = 1;
        while (i <= numberOfEnemies) {
            int randomIndex = random.nextInt(freeTileIndex.size());
            int[] tileIndex = freeTileIndex.get(randomIndex);
            if (((EmptyTile) stageModel.getTile(tileIndex[0], tileIndex[1])).getOccupant() != null) {
                continue;
            }
            EnemyModel enemyModel;
            EntityView enemyView;
            if ((i % (numberOfEnemies / level )) != 0) { // alternate between enemy types
                enemyModel = new EnemyModel1(tileIndex[0] * stageModel.getTileSize(), tileIndex[1] * stageModel.getTileSize() - 10,  stageModel);
                enemyView = new EntityView("enemy1");
            }
            else {
                enemyModel = new EnemyModel2(tileIndex[0] * stageModel.getTileSize(), tileIndex[1] * stageModel.getTileSize() - 10, stageModel);
                enemyView = new EntityView("enemy2", true, 6);
            }
            if (stageModel.getTile(tileIndex[0], tileIndex[1] - 1) instanceof EmptyTile || stageModel.getTile(tileIndex[0], tileIndex[1] + 1) instanceof EmptyTile) {
                enemyModel.startMoving("UP");
            } else {
                enemyModel.startMoving("RIGHT");
            }
            enemyModel.addListener(enemyView); // add view as observer
            gameLayer.getChildren().add(enemyView.getEntitySprite());
            addEnemy(enemyModel);
            i++;
        }
    }
    public void addEnemy(EnemyModel enemy) {
        enemies.add(enemy);
    }
    public void removeEnemy(EnemyModel enemy) {
        int index = enemies.indexOf(enemy);
        if (index != -1) {
            enemies.remove(index);
        }
    }
    public List<EnemyModel> getEnemies() {
        return enemies;
    }
    public void updateState(double elapsed) {
        // update enemy
        enemies.forEach(enemy -> enemy.updateState(elapsed));
        // Remove dead enemies
        IntStream.range(0, enemies.size()) //iterate over indices
            .filter(i -> enemies.get(i).isDead()) // filter, keep only dead enemies
            .boxed() // convert to Integer
            .collect(Collectors.toCollection(LinkedList::new)) // collect to LinkedList
            .descendingIterator() // iterate in reverse order to avoid index shift
            .forEachRemaining(i -> { // remove dead enemies
                enemies.remove((int)i);
            });
    }
}
package com.esame;
public abstract class EnemyModel extends EntityModel {
    public EnemyModel(int initialX, int initialY, int[] boundingBox, int[] boundingOffset, int life, StageModel stage) {
        super(initialX, initialY, boundingBox, boundingOffset, life, stage);
    }
    @Override
    public EntityModel checkCollision(int dx, int dy) {
        EntityModel occupant = super.checkCollision(dx, dy);
        if (occupant instanceof PlayerModel) {
            occupant.loseLife(1);
        }
        notifyListeners();
        return occupant;
    }
    public abstract void movingBehaviour();
    @Override
    public void updateState(double elapsedTime) {
        super.updateState(elapsedTime);
        movingBehaviour();
        notifyListeners();
    }
}
package com.esame;
public class EnemyModel1 extends EnemyModel {
    public EnemyModel1(int initialX, int initialY, StageModel stage) {
        super(initialX, initialY, new int[] {15, 15}, new int[] {8, 17}, 100, stage);
    }
    @Override
    public void movingBehaviour() {
        if (!this.isMoving) {
            this.startMoving(new int[] {-lastDirection[0], -lastDirection[1]});
        }
    }
}
package com.esame;
public class EnemyModel2 extends EnemyModel {
    public EnemyModel2(int initialX, int initialY, StageModel stage) {
        super(initialX, initialY, new int[] {15, 15}, new int[] {8, 17}, 200, stage);
        // Metà della velocità del nemico originale, altrimenti e' troppo difficile da battere
        this.setVelocity(this.getVelocity() * 0.7);
    }
    @Override
    public void loseLife(int amount) {
        super.loseLife(amount);
        if (isDead()) return;
        boolean new_pos = false;
        // Imposta l'occupante della tile corrente a null
        ((EmptyTile) getStage().getTileAtPosition((int) this.centerOfMass()[0], (int) this.centerOfMass()[1])).setOccupant(null);
        while (!new_pos) {
            int[] randomXY = getStage().getRandomFreeTile();
            if (getStage().getTile(randomXY[0], randomXY[1]) instanceof EmptyTile && ((EmptyTile) getStage().getTile(randomXY[0], randomXY[1])).getOccupant() == null) {
                this.xProperty().set(randomXY[0] * getStage().getTileSize() - this.getBoundingBox()[0] / 2);
                this.yProperty().set(randomXY[1] * getStage().getTileSize() - this.getBoundingBox()[1] / 2);
                new_pos = true;
            }
        }
        notifyListeners();
    }
    @Override
    public void movingBehaviour() {
        int lastX = lastDirection[0];
        int lastY = lastDirection[1];
        // Se il nemico non si sta muovendo, resetta le ultime coordinate
        if (!isMoving()) {
            lastX = 0;
            lastY = 0;
        }
        int randomDirection = (int) (Math.random() * 4); // Genera un numero casuale tra 0 e 3
        // Muove il nemico in una direzione casuale
        if (randomDirection == 0 && canMoveTo(1, 0) && lastX != -1) {
            startMoving(1, 0);
        }
        else if (randomDirection == 1 && canMoveTo(-1, 0) && lastX != 1) {
            startMoving(-1, 0);
        }
        else if (randomDirection == 2 && canMoveTo(0, -1) && lastY != 1) {
            startMoving(0, -1);
        }
        else if (randomDirection == 3 && canMoveTo(0, 1) && lastY != -1) {
            startMoving(0, 1);
        }
    }
}
package com.esame;
import javafx.beans.InvalidationListener;
import javafx.beans.Observable;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.IntegerProperty;
import javafx.beans.property.SimpleDoubleProperty;
import javafx.beans.property.SimpleIntegerProperty;
import java.util.List;
import java.util.ArrayList;
public abstract class EntityModel extends XYModel implements Observable{
    protected List<EntityStateObserver> observers = new ArrayList<>();
    protected final IntegerProperty life = new SimpleIntegerProperty(100);
    protected final DoubleProperty velocity = new SimpleDoubleProperty(1);
    protected IntegerProperty centerX = new SimpleIntegerProperty();
    protected IntegerProperty centerY = new SimpleIntegerProperty();
    protected double timeSinceLastMove = 0.0;
    protected double delayMove = 0.05; // Time in seconds between moves
    protected final int[] boundingBox = {0, 0};
    protected final int[] boundingOffset = {0, 0};
    protected boolean isMoving = false;
    protected int[] lastDirection = {0, 0};
    protected StageModel stage;
    protected ArrayList<EmptyTile> occupiedTiles = new ArrayList<>();
    public EntityModel(int x, int y, StageModel stage) {
        this(x, y, new int[] {16, 16}, new int[] {16, 16}, 100, null);
    }
    public EntityModel(int x, int y, int[] boundingBox, int[] boundingOffset,  int life, StageModel stage) {
        super(x, y);
        this.stage = stage;
        this.life.set(life);
        if (boundingBox!=null && boundingOffset.length == 2){
            this.boundingBox[0] = boundingBox[0];
            this.boundingBox[1] = boundingBox[1];
        }
        if (boundingOffset!=null && boundingOffset.length == 2){
            this.boundingOffset[0] = boundingOffset[0];
            this.boundingOffset[1] = boundingOffset[1];
        }
        centerX.bind(this.x.add(this.boundingOffset[0]));
        centerY.bind(this.y.add(this.boundingOffset[1]));
        setOccupiedTiles();
    }
    @Override
    public void addListener(InvalidationListener listener) {
        observers.add((EntityStateObserver) listener);
    }
    @Override
    public void removeListener(InvalidationListener listener) {
        observers.remove((EntityStateObserver) listener);
    }
    protected void notifyListeners() {
        for (EntityStateObserver observer : observers) {
            observer.update(this);
        }
    }
    public void loseLife(int amount) {
        AudioUtils.playSoundEffect("LoseLife.mp3");
        this.life.set(getLife() - amount);
        if (isDead()) {
            clearOccupiedTiles();
        }
        notifyListeners();
    }
    public boolean isDead() {
        return getLife() <= 0;
    }
    public void setLife(int amount) {
        this.life.set(amount);
        notifyListeners();
    }
    public int getLife() {
        return life.get();
    }
    public DoubleProperty velocityProperty() {
        return velocity;
    }
    public double getVelocity() {
        return velocity.get();
    }
    public void setVelocity(double velocity) {
        this.velocity.set(velocity);
        notifyListeners();
    }
    public StageModel getStage() {
        return stage;
    }
    public int[] getBoundingBox() {
        return boundingBox;
    }
    public int[] getBoundingOffset() {
        return boundingOffset;
    }
    public int[] getLastDirection() {
        return lastDirection;
    }
    public String getLastDirectionString() {
        if (lastDirection[0] == 0 && lastDirection[1] == -1) return "UP";
        else if (lastDirection[0] == 0 && lastDirection[1] == 1) return "DOWN";
        else if (lastDirection[0] == -1 && lastDirection[1] == 0) return "LEFT";
        else if (lastDirection[0] == 1 && lastDirection[1] == 0) return "RIGHT";
        else return "";
    }
    public boolean isMoving() {
        return isMoving;
    }
    public void setBoundingBox(int[] boundingBox) {
        this.boundingBox[0] = boundingBox[0];
        this.boundingBox[1] = boundingBox[1];
    }
    public void setBoundingOffset(int[] boundingOffset) {
        this.boundingOffset[0] = boundingOffset[0];
        this.boundingOffset[1] = boundingOffset[1];
    }
    public void setStage(StageModel stage) {
        this.stage = stage;
        notifyListeners();
    }
    public SimpleIntegerProperty centerXProperty() {
        return (SimpleIntegerProperty) centerX;
    }
    public SimpleIntegerProperty centerYProperty() {
        return (SimpleIntegerProperty) centerY;
    }
    public int getCenterX() {
        return centerX.get();
    }
    public int getCenterY() {
        return centerY.get();
    }
    public int[] centerOfMass() {
        return new int[] {centerX.get(), centerY.get()};
    }
    public void clearOccupiedTiles() {
        for (EmptyTile tile : occupiedTiles) {
            tile.setOccupant(null);
        }
        occupiedTiles.clear();
    }
    public void setOccupiedTiles() {
        clearOccupiedTiles();     
        for (int x = -1; x <= 1; x++) {
            for (int y = -1; y <= 1; y++) {
                // skip the cornern tiles {1, 1}, {1, -1}, {-1, 1}, {-1, -1}
                if (x != 0 && y !=0 && (x == y || x == -y)) continue;
                int tileX = centerX.get() + x * boundingBox[0] / 2;
                int tileY = centerY.get() + y * boundingBox[1] / 2;
                EmptyTile tile = stage.getEmptyTileAtPosition(tileX, tileY);
                tile.setOccupant(this);
                occupiedTiles.add(tile);
            }
        }
    }
    public void move(int dx, int dy) {
        int x_move = (int) Math.round(this.velocityProperty().get() * Double.valueOf(dx)); // explicit cast to int
        int y_move = (int) Math.round(this.velocityProperty().get() * Double.valueOf(dy)); // explicit cast to int
        if (canMoveTo(dx, dy) && (checkCollision(dx, dy) == null || checkCollision(dx, dy) == this)) {
            xProperty().set(getX() + x_move);
            yProperty().set(getY() + y_move);
            // Update tiles occupancy
            setOccupiedTiles();
            notifyListeners();
        }
        else isMoving = false;
    }
    public EntityModel checkCollision(int dx, int dy) {
        int xSign = Integer.signum(dx);
        int ySign = Integer.signum(dy);
        int directionOffset = 3;
        int tileXCollision = (int) centerX.get() + xSign * boundingBox[0] / 2 + xSign * directionOffset;
        int tileYCollision = (int) centerY.get()  + ySign * boundingBox[1] / 2 + ySign * directionOffset;
        return stage.getEmptyTileAtPosition(tileXCollision, tileYCollision).getOccupant();
    }
    protected boolean canMoveTo(int dx, int dy) {
        int xSign = Integer.signum(dx);
        int ySign = Integer.signum(dy);
        int tileX = centerX.get();
        int tileY = centerY.get() ;
        int directionOffset = 2;
        Tile collisionTile;
        if (dx != 0){
            int tileXCollision = (int) centerX.get() + xSign * boundingBox[0] / 2 + xSign * directionOffset;
            collisionTile = stage.getTileAtPosition(tileXCollision, tileY);
            // controlla la tile direttamente sull'asse x della bounding box
            if (!collisionTile.isWalkable()) return false;
            // scontro col bordo di una tile mentre sopra non c'e' nulla --> e' uno spigolo e bisogna fermarsi
            int tileYCollision = (int) centerY.get()  - boundingBox[1] / 2;
            collisionTile = stage.getTileAtPosition(tileXCollision, tileYCollision);
            if (stage.getTileAtPosition(tileX, tileYCollision) instanceof EmptyTile && !collisionTile.isWalkable()) return false;
            tileYCollision = (int) centerY.get()  + boundingBox[1] / 2;
            collisionTile = stage.getTileAtPosition(tileXCollision, tileYCollision);
            if (stage.getTileAtPosition(tileX, tileYCollision) instanceof EmptyTile && !collisionTile.isWalkable()) return false;
        }
        // stessa cosa se lo spostamento e' sull'asse y
        else if (dy != 0){
            int tileYCollision = (int) centerY.get() + ySign * boundingBox[1] / 2 + ySign * directionOffset;
            collisionTile = stage.getTileAtPosition(tileX, tileYCollision);
            if (!collisionTile.isWalkable()) return false;
            int tileXCollision = (int) centerX.get() - boundingBox[0] / 2;
            collisionTile = stage.getTileAtPosition(tileXCollision, tileYCollision);
            if (stage.getTileAtPosition(tileXCollision, tileY) instanceof EmptyTile && !collisionTile.isWalkable()) return false;
            tileXCollision = (int) centerX.get() + boundingBox[0] / 2;
            collisionTile = stage.getTileAtPosition(tileXCollision, tileYCollision);
            if (stage.getTileAtPosition(tileXCollision, tileY) instanceof EmptyTile && !collisionTile.isWalkable()) return false;
        }
        return true; // in tutte le direzioni della bouinding box non c'e' collisione
    }
    public void startMoving(int[] direction) {
            lastDirection[0] = direction[0];
            lastDirection[1] = direction[1];
            isMoving = true;
            if (direction[0] == 0 && direction[1] == 0) {
                isMoving = false;
            }
    }
    public void startMoving(int dx, int dy) {
        lastDirection[0] = dx;
        lastDirection[1] = dy;
        isMoving = true;
        if (dx == 0 && dy == 0) {
            isMoving = false;
        }
}
    public void startMoving(String direction) {
        switch (direction) {
            case "UP":
                lastDirection[0] = 0;
                lastDirection[1] = -1;
                isMoving = true;
                break;
            case "DOWN":
                lastDirection[0] = 0;
                lastDirection[1] = 1;
                isMoving = true;
                break;
            case "LEFT":
                lastDirection[0] = -1;
                lastDirection[1] = 0;
                isMoving = true;
                break;
            case "RIGHT":
                lastDirection[0] = 1;
                lastDirection[1] = 0;
                isMoving = true;
                break;
            default:
                isMoving = false;
                break;
        }
    }
    public void stopMoving() {
        isMoving = false;
        notifyListeners();
    }
    public void updateState(double elapsedTime){
        if (isDead()) {
            return;
        }
        timeSinceLastMove += elapsedTime;
        // il tempo di delay viene diviso per la velocita' in modo da diminuire se aumenta la velocita'
        if (isMoving && timeSinceLastMove >= delayMove / velocity.get()) {
            move(lastDirection[0], lastDirection[1]);
            timeSinceLastMove = 0.0; // Reset the timer
        }
        notifyListeners();
    }
}
package com.esame;
import javafx.beans.InvalidationListener;
public interface EntityStateObserver extends InvalidationListener {
    
    void update(EntityModel entityModel);
}
package com.esame;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.geometry.Rectangle2D;
import javafx.animation.Animation;
import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.beans.Observable;
import javafx.util.Duration;
import java.util.HashMap;
import java.util.Map;
import java.util.stream.IntStream;
public class EntityView implements EntityStateObserver{
    private final ImageView EntitySprite;
    private String lastDirection;
    private Map<String, Integer> directionSprite = new HashMap<>();
    private Timeline walkAnimation = null;
    private boolean autoReverse = false;
    private int frames = 4;
    int row = 0;
    public EntityView(String spriteName)
    {
        this(spriteName, false, 4, 0);
    }
    public EntityView(String spriteName, boolean autoReverse, int frames)
    {
        this(spriteName, autoReverse, frames, 0);
    }
    
    public EntityView(String spriteName, boolean autoReverse, int frames, int row) {
        this.autoReverse = autoReverse;
        this.frames = frames;
        this.row = row;
        // this.spriteName = spriteName;
        this.directionSprite = new HashMap<String, Integer>() {{
            put("DOWN",  16 + 16 * frames * 0);
            put("LEFT",  16 + 16 * frames * 1);
            put("RIGHT", 16 + 16 * frames * 2);
            put("UP",    16 + 16 * frames * 3);
        }};
        // Load the sprite image
        Image image = new Image(getClass().getResourceAsStream("/sprites/" + spriteName + ".png"));
        this.EntitySprite = new ImageView(image);
        
        // Set the default sprite for the entity
        EntitySprite.setViewport(new Rectangle2D(directionSprite.get("DOWN") + 16, 24 * row, 16, 24)); 
        // Bind the ImageView's position to the model's position
        // EntitySprite.layoutXProperty().bind(model.xProperty());
        // EntitySprite.layoutYProperty().bind(model.yProperty());
    }
    public ImageView getEntitySprite() {
        return EntitySprite;
    }
    public void startWalking(String direction, double velocity) {
        if (lastDirection != direction) {
            lastDirection = direction;
            EntitySprite.setViewport(new Rectangle2D(directionSprite.get(direction) + 16, 24 * row, 16, 24)); // Iniziliazza la direzione della view
            // Stop the current animation if it's running
            if (walkAnimation != null && walkAnimation.getStatus() == Animation.Status.RUNNING) {
                walkAnimation.stop();
            }
            double animationFrameTime = 0.2 / velocity;
            walkAnimation = new Timeline();
            IntStream.range( 0, frames).forEach(i -> {
                walkAnimation.getKeyFrames().add(
                    new KeyFrame(Duration.seconds(animationFrameTime * i), e -> EntitySprite.setViewport(new Rectangle2D(directionSprite.get(direction) + 16 * i, 24 * row, 16, 24)))
                );
            });
            walkAnimation.setAutoReverse(autoReverse);
            walkAnimation.setCycleCount(Animation.INDEFINITE);
            walkAnimation.play();
        }
        if (walkAnimation.getStatus() !=  Animation.Status.RUNNING){
            walkAnimation.play();
        }
    }
    public void stopWalking() {
        if (walkAnimation != null) {
            walkAnimation.stop();
        }
        if (lastDirection != null) {
            EntitySprite.setViewport(new Rectangle2D(directionSprite.get(lastDirection) + 16, 24 * row, 16, 24));
        }
    }
    public void setFrames(int frames) {
        this.frames = frames;
    }
    @Override
    public void invalidated(Observable observable) {
        EntitySprite.setVisible(false);
    }
    @Override
    public void update(EntityModel model) {
        // Update the position of the entity
        EntitySprite.layoutXProperty().set(model.getX());
        EntitySprite.layoutYProperty().set(model.getY());
        if (model.isDead()) {
            EntitySprite.setVisible(false);
            return;
        }
        if (model.isMoving()) {
            startWalking(model.getLastDirectionString(), model.velocityProperty().get());
        }
        else {
            stopWalking();
        }
    }
}
package com.esame;
import javafx.application.Application;
import javafx.application.Platform;
import javafx.scene.Scene;
import javafx.scene.layout.*;
import javafx.stage.Stage;
import java.io.File;
import java.io.IOException;
import java.net.URISyntaxException;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.List;
import javafx.animation.AnimationTimer;
// import stuff to have a dialog box
import javafx.scene.control.Alert;
import javafx.scene.control.ButtonType;
import javafx.scene.control.DialogPane;
import javafx.scene.control.Alert.AlertType;
import java.util.Optional;
public class GameApp extends Application {
    
    private PlayerData data;
    private StageModel stageModel;
    private PlayerController playerController;
    private BombController bombController;
    private PlayerModel playerModel;
    private EnemiesController enemiesController;
    private int numberOfEnemies;
    private BackgroundMusic backgroundMusic = new BackgroundMusic();
    public Void initializeGame(PlayerData data, int numberOfEnemies) {
        this.data = data;
        this.numberOfEnemies = numberOfEnemies;
        return null;
    }
    @Override
    public void start(Stage primaryStage) {        
        // Setup the game with the provided player data
        setupGame(primaryStage, data.getLastLevelInt());
        // Create and start the game loop using AnimationTimer
        AnimationTimer gameLoop = new AnimationTimer() {
            @Override
            public void handle(long now) {
                // Check for player death or level completion
                if (playerModel.isDead() || (enemiesController.getEnemies().isEmpty() && playerModel.isOnNextLevelDoor())) {
                    // Stop the game loop first to prevent any updates while the dialog is shown
                    playerModel.stopMoving(); 
                    backgroundMusic.stopMusic();
                    this.stop();
                    int current_level = data.getLastLevelInt();
                    // save the data
                    if (playerModel.isDead()) {
                        data.setLostGames(data.getLostGamesInt() + 1);
                        AudioUtils.playSoundEffect("GameOver.mp3");
                    } else {
                        data.setWinGames(data.getWinGamesInt() + 1);
                        AudioUtils.playSoundEffect("StageClear.mp3");
                        // Don't go to higher levels than 3
                        if (data.getLastLevelInt() < 3) {
                            data.setLastLevel(data.getLastLevelInt() + 1);
                        }
                        else {
                            numberOfEnemies ++ ;
                        }
                    }
                    data.setScore(playerModel.getScore());
                    data.setPlayedGames(data.getPlayedGamesInt() + 1);
                    savePlayerData();
                    // Use Platform.runLater to show the dialog after the current animation frame is processed
                    Platform.runLater(() -> {
                        Alert alert = new Alert(AlertType.CONFIRMATION);
                        // Applying the CSS file to the DialogPane
                        DialogPane dialogPane = alert.getDialogPane();
                        dialogPane.getStylesheets().add(getClass().getResource("/styles/styles.css").toExternalForm());
                        // Add buttons to the dialog
                        alert.setTitle(playerModel.isDead() ? "Game Over!" : "Level Complete!");
                        alert.getDialogPane().setGraphic(null);
                        alert.setHeaderText(playerModel.isDead() ? "Game over!" : "Level Complete!");
                        if (!playerModel.isDead()) {
                            if (current_level == 3) {
                                alert.setContentText("Congratulations! You have completed all levels! Let's try more enemies?");
                            } else {
                                alert.setContentText("Well done! Proceed to the next level?");
                            }
                        } else {
                            alert.setContentText("You can do it! Try again!");
                        }
                        ButtonType buttonRestartOrContinue = new ButtonType(playerModel.isDead() ? "Try again" : "Continue");
                        ButtonType buttonExit = new ButtonType("Exit to Main Menu");
                        ButtonType buttonQuit = new ButtonType("Quit");
                        
                        alert.getButtonTypes().setAll(buttonRestartOrContinue, buttonExit, buttonQuit);
                        Optional<ButtonType> result = alert.showAndWait();
                        if (result.isPresent() && result.get() == buttonRestartOrContinue) {
                            if (playerModel.isDead()) {
                                // Restart current level if the player died
                                playerModel = null;
                                setupGame(primaryStage, data.getLastLevelInt());
                            } else {
                                // Setup game for next level if the current one was completed
                                setupGame(primaryStage, data.getLastLevelInt());
                            }
                            // Restart the game loop
                            this.start();
                        } else if (result.isPresent() && result.get() == buttonExit) {
                            // Instead of closing the primary stage, re-use it for the pre-game setup
                            Platform.runLater(() -> {
                                MainMenu mainMenu = new MainMenu();
                                try {
                                    mainMenu.start(primaryStage);
                                } catch (Exception e) {
                                    e.printStackTrace();
                                }
                            });
                        }
                        else if (result.isPresent() && result.get() == buttonQuit) {
                            // Stop the background music
                            backgroundMusic.stopMusic();
                            AudioUtils.stopAll();
                            // Quit the application
                            Platform.exit();
                        }
                    });
                } else {
                    // Regular game update logic if no special conditions met
                    enemiesController.updateState(1.0 / 60.0);
                    playerController.updateState(1.0 / 60.0);
                    bombController.updateState(1.0 / 60.0);
                    stageModel.notifyListeners();
                }
            }
        };
        gameLoop.start();
    }
    
    private void setupGame(Stage primaryStage, int level) {
        AudioUtils.playSoundEffect("StageStart.mp3");
        // Use a StackPane as the root to allow layering of the map and the player
        StackPane root = new StackPane();
        Pane bombLayer = new Pane();
        Pane gameLayer = new Pane();
        BorderPane borderPane = new BorderPane();
        // Initialize the Stage
        this.stageModel = new StageModel();
        StageView stageView = new StageView(level);
        stageModel.addListener(stageView);
        Scene mainScene = new Scene(borderPane, 272, 224);
        mainScene.getStylesheets().add(getClass().getResource("/styles/styles.css").toExternalForm());
        primaryStage.setTitle("Jbomberan level " + level);
        primaryStage.setScene(mainScene);
        primaryStage.show();
        // initialize playerModel, view, and controller
        if (this.playerModel == null) {
            stageModel.setPlayer(playerModel);
            this.playerModel = new PlayerModel(32, 6, stageModel);
        }
        else {
            this.playerModel.setPosition(32, 6);
            this.playerModel.setStage(stageModel);
        }
        stageModel.setPlayer(playerModel);
        this.playerController = new PlayerController(playerModel, Integer.parseInt(data.getAvatar()));
        this.enemiesController = new EnemiesController(numberOfEnemies, stageModel, gameLayer, level);
        // Layer the map and the player on the StackPane
        root.getChildren().add(stageView.getPane()); // Map as the base layer
        gameLayer.getChildren().add(playerController.getView().getEntitySprite()); // Add Bomberman on top of the map
        root.getChildren().add(bombLayer); // Add the bomb layer to the root
        root.getChildren().add(gameLayer); // Add the game layer to the root
        // usa un BorderPane per posizionare l'HUD sopra il gioco
        HUDView hudView = new HUDView();
        PlayerSound playerSound = new PlayerSound(); // inizializza il playerSound
        // aggiungi HUD come osservatore del playerModel
        playerModel.addListener(hudView);
        playerModel.addListener(playerSound); // aggiungi playerSound come osservatore del playerModel
        hudView.update(playerModel); // initializza l'HUD con i valori iniziali
        borderPane.setCenter(root); // Set the game (map + player) as the center
        borderPane.setTop(hudView.getHudPane()); // Set the HUD at the top
        // Setup the controller with the scene
        this.bombController = new BombController(playerModel, bombLayer);
        new InputController(playerController, bombController, mainScene);
        backgroundMusic.playMusic("Background.mp3");
    }
    public void savePlayerData() {
        try {
            // Get the path to the JAR file
            String jarPath = new File(GameApp.class.getProtectionDomain().getCodeSource().getLocation().toURI()).getPath();
            // Get the directory of the JAR file
            String dirPath = new File(jarPath).getParent();
            // Construct the path to the players.txt file in the same directory
            File file = new File(dirPath, "savedGames.txt");
            // Prepare data to save
            String dataToSave = data.getDataString();
            // Check if data for the player already exists and needs to be updated, or append new data
            List<String> lines = file.exists() ? Files.readAllLines(file.toPath()) : new ArrayList<>();
            lines.removeIf(String::isEmpty); // Remove any empty lines
            boolean dataExists = false;
            for (int i = 0; i < lines.size(); i++) {
                String line = lines.get(i);
                String nickname = line.split(",")[0];
                if (nickname.equals(data.getNickname())) {
                    lines.set(i, dataToSave); // Update existing data
                    dataExists = true;
                    break;
                }
            }
            if (!dataExists && !dataToSave.isEmpty()) {
                lines.add(dataToSave); // Append new player data
            }
            // Write data to the file
            Files.write(file.toPath(), lines);
        } catch (URISyntaxException e) {
            System.err.println("Error parsing URI: " + e.getMessage());
        } catch (IOException e) {
            System.err.println("IO error occurred: " + e.getMessage());
        } catch (Exception e) {
            System.err.println("An unexpected error occurred: " + e.getMessage());
        }
    }
}
package com.esame;
import javafx.beans.Observable;
import javafx.geometry.Pos;
import javafx.scene.control.Label;
import javafx.scene.layout.HBox;
import javafx.scene.paint.Color;
public class HUDView implements EntityStateObserver{
    private HBox hudPane;
    private Label scoreLabel;
    private Label livesLabel;
    private Label bombCapacityLabel;
    private Label bombRadiusLabel;
    public HUDView() {
        hudPane = new HBox(10);
        hudPane.getStylesheets().add(getClass().getResource("/styles/styles.css").toExternalForm());
        hudPane.setAlignment(Pos.TOP_CENTER);
        
        scoreLabel = new Label();
        livesLabel = new Label();
        bombCapacityLabel = new Label();
        bombRadiusLabel = new Label();
        /*
         * Codice opzionale, usa JavaFX puoi usare il binding per aggiornare i valori
         * invece del classico Observer pattern.
         * Se si usa il JavaFx, e' necessario avere il playerModel come parametro del costruttore
        // bombCapacityLabel.textProperty().bind(playerModel.bombCapacityProperty().asString("Bombs: %d"));
        // bombRadiusLabel.textProperty().bind(playerModel.bombRadiusProperty().asString("Radius: %d"));
        // scoreLabel.textProperty().bind(playerModel.scoreProperty().asString("Score: %d"));
        // livesLabel.textProperty().bind(playerModel.lifeProperty().asString("Life: %d"));
        // // Aggiungi un listener per cambiare il colore del testo a seconda del valore della vita
        // playerModel.lifeProperty().addListener((observable, oldValue, newValue) -> {
        //     if (newValue.intValue() == 3) {
        //         livesLabel.setTextFill(Color.GREEN);
        //     } else if (newValue.intValue() == 2) {
        //         livesLabel.setTextFill(Color.INDIANRED);
        //     } else if (newValue.intValue() == 1) {
        //         livesLabel.setTextFill(Color.CRIMSON);
        //     }
        // });
        hudPane.getChildren().addAll(scoreLabel, livesLabel, bombCapacityLabel, bombRadiusLabel);
    }
    public HBox getHudPane() {
        return hudPane;
    }
    @Override
    public void invalidated(Observable observable) {
        scoreLabel.setText("Score: /");
        bombCapacityLabel.setText("Bombs: /");
        bombRadiusLabel.setText("Radius: /");
        livesLabel.setText("Life: /");      
    }
    
    @Override
    public void update(EntityModel playerEntityModel) {
        PlayerModel playerModel = (PlayerModel) playerEntityModel;
        scoreLabel.setText("Score: " + playerModel.getScore());
        bombCapacityLabel.setText("Bombs: " + playerModel.getBombCapacity());
        bombRadiusLabel.setText("Radius: " + playerModel.getBombRadius());
        livesLabel.setText("Life: " + playerModel.getLife());
        // Seleziona il colore della vita a seconda del valore
        if (playerModel.getLife() == 3) {
            livesLabel.setTextFill(Color.GREEN);
        } else if (playerModel.getLife() == 2) {
            livesLabel.setTextFill(Color.INDIANRED);
        } else if (playerModel.getLife() == 1) {
            livesLabel.setTextFill(Color.CRIMSON);
        }
    }
}
package com.esame;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import javafx.scene.Scene;
import javafx.scene.input.KeyCode;
public class InputController {
    private final Set<KeyCode> keysPressed = ConcurrentHashMap.newKeySet(); // per far muovere il player appena si preme un tasto
    private Scene scene;
    private PlayerController player;
    private BombController bomb;
    public InputController(PlayerController player, BombController bomb,  Scene scene) {
        this.player = player;
        this.bomb = bomb;
        this.scene = scene;
        attachEventListeners();
    }
    private void attachEventListeners() {
        scene.setOnKeyPressed(event -> {
            KeyCode code = event.getCode();
            if (!keysPressed.contains(code)) { // Check to prevent repeated calls for the same key press
                keysPressed.add(code);
                pressedController(); // Move as soon as the key is pressed
            }
        });
        scene.setOnKeyReleased(event -> {
            keysPressed.remove(event.getCode());
            releaseController();
        });
    }
    
    private void pressedController() {
        if (keysPressed.contains(KeyCode.SPACE)) {
            bomb.input();
        } 
        if (keysPressed.contains(KeyCode.UP)) {
            player.input("UP");
        } else if (keysPressed.contains(KeyCode.DOWN)) {
            player.input("DOWN");
        } else if (keysPressed.contains(KeyCode.LEFT)) {
            player.input("LEFT");
        } else if (keysPressed.contains(KeyCode.RIGHT)) {
            player.input("RIGHT");
        } else {
            player.input(null);
        }
    }
    
    public void releaseController() {
        if (keysPressed.contains(KeyCode.UP)) {
            player.input("UP");
        } else if (keysPressed.contains(KeyCode.DOWN)) {
            player.input("DOWN");
        } else if (keysPressed.contains(KeyCode.LEFT)) {
            player.input("LEFT");
        } else if (keysPressed.contains(KeyCode.RIGHT)) {
            player.input("RIGHT");
        } else {
            player.input(null);
        }
    }
}
package com.esame;
import javafx.application.Application;
import javafx.geometry.Rectangle2D;
import javafx.scene.Scene;
import javafx.scene.control.*;
import javafx.scene.layout.VBox;
import javafx.scene.text.Font;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.stage.Stage;
import java.io.File;
import java.io.IOException;
import java.net.URISyntaxException;
import java.nio.file.Files;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
public class MainMenu extends Application {
    private Map<String, PlayerData> playerDataMap = new HashMap<>();
    private ImageView avatarPreview = new ImageView();
    private Label statsLabel1 = new Label(); 
    private Label statsLabel2 = new Label(); 
    @Override
    public void start(Stage primaryStage) throws Exception {
        // fai partire la musica
        BackgroundMusic backgroundMusic = new BackgroundMusic();
        backgroundMusic.playMusic("MainMenu.mp3");
        // Inizializza lo stage
        Font.loadFont(getClass().getResourceAsStream("/fonts/Pixelify_Sans/static/PixelifySans-Regular.ttf"), 14);
        primaryStage.setTitle("JBomberman");
        readPlayerData(); // Read player data from file
        TextField nicknameField = new TextField();
        nicknameField.setPrefWidth(10);
        // Number of enemies
        // Spinner for selecting the number of enemies
        Spinner<Integer> enemySpinner = new Spinner<>(1, 30, 4);
        enemySpinner.setEditable(true);
        // Listen for changes in the nickname field and update stats
        nicknameField.textProperty().addListener((observable, oldValue, newValue) -> {
            PlayerData data = playerDataMap.get(newValue);
            if (data != null) {
                // Update stats label with player data
                statsLabel1.setText(String.format("Played Games: %s; Won: %s; Lost: %s;", data.getPlayedGames(), data.getWinGames(), data.getLostGames()));
                statsLabel2.setText(String.format("Last Level: %s; Highest Score: %s", data.getLastLevel(), data.getScore()));
            } else {
                statsLabel1.setText("New player!");
                statsLabel2.setText("");
            }
        });
        // Select Avatar
        ComboBox<String> avatarComboBox = new ComboBox<>();
        avatarComboBox.getItems().addAll("1", "2", "3", "4"); // Assuming these are your avatar options
        String defaultAvatar = "1"; // Default avatar
        // prova a caricare l'ultimo avatar usato
        if (playerDataMap.containsKey(nicknameField.getText())) {
            defaultAvatar = playerDataMap.get(nicknameField.getText()).getAvatar();
        }
        avatarComboBox.setValue(defaultAvatar);
        updateAvatarPreview(defaultAvatar); // Update the avatar preview based on the default value (1)
        avatarComboBox.setOnAction(e -> updateAvatarPreview(avatarComboBox.getValue()));
        // Start Game Button
        Button startGameButton = new Button("Start Game");
        startGameButton.setOnAction(e -> {
            String nickname = nicknameField.getText();
            String avatar = avatarComboBox.getValue();
            PlayerData data = playerDataMap.getOrDefault(nickname, new PlayerData(nickname, avatar, "1", "0", "0", "0", "0")); 
            try {
                GameApp gameApp = new GameApp();
                backgroundMusic.stopMusic();
                gameApp.initializeGame(data, enemySpinner.getValue());
                gameApp.start(new Stage());
            } catch (Exception ex) {
                ex.printStackTrace();
            }
            primaryStage.close(); // Close the setup window
        });
        // Setup the layout
        VBox layout = new VBox(10, new Label("Nickname:"), nicknameField, 
                                new Label("Number of Enemies:"), enemySpinner, 
                                new Label("Choose Avatar:"), avatarComboBox, avatarPreview, 
                                statsLabel1, statsLabel2, 
                                startGameButton);
        Scene scene = new Scene(layout, 272, 310);
        scene.getStylesheets().add(getClass().getResource("/styles/styles.css").toExternalForm());
        primaryStage.setScene(scene);
        primaryStage.show();
    }
    private void readPlayerData() {
        // List<PlayerData> playerDataList = new ArrayList<>();
        try {
            // Get the path to the JAR file
            String jarPath = new File(MainMenu.class.getProtectionDomain().getCodeSource().getLocation().toURI()).getPath();
            // Get the directory of the JAR file
            String dirPath = new File(jarPath).getParent();
            // Construct the path to the players.txt file in the same directory
            File file = new File(dirPath, "savedGames.txt");
            if (file.exists()) {
                // Read all lines from the players.txt file
                List<String> lines = Files.readAllLines(file.toPath());
                // Parse each line into PlayerData objects
                for (String line : lines) {
                    String[] parts = line.split(",");
                    if (parts.length == 7) {
                        String nickname = parts[0];
                        String avatarNumber = parts[1];
                        String lastLevel = parts[2];
                        String playedGames = parts[3];
                        String winGames = parts[4];
                        String lostGames = parts[5];
                        String score = parts[6];
                        PlayerData playerData = new PlayerData(nickname, avatarNumber, lastLevel, playedGames, winGames, lostGames, score);
                        playerDataMap.put(nickname, playerData);
                    }
                }
            }
        } catch (URISyntaxException e) {
            System.err.println("Error parsing URI: " + e.getMessage());
        } catch (IOException e) {
            System.err.println("IO error occurred: " + e.getMessage());
        } catch (Exception e) {
            System.err.println("An unexpected error occurred: " + e.getMessage());
        }
    }
    private void updateAvatarPreview(String avatarNumber) {
        Image avatarImage = new Image(getClass().getResourceAsStream("/sprites/bomberman.png"));
        int avatarIndex = Integer.parseInt(avatarNumber) - 1; // Assuming avatarNumber starts at 1
        avatarPreview.setImage(avatarImage); // avatarPreview should be an ImageView
        avatarPreview.setViewport(new Rectangle2D(0, 24 * avatarIndex, 47, 24)); // Update this to match your sprite sheet
    }
    public static void main(String[] args) {
        AudioUtils.preloadAll(); // Preload all sound effects
        launch(args);
    }
    public void show(Stage stage) throws Exception {
        // Setup your pre-game scene
        VBox layout = new VBox(10);
        Scene scene = new Scene(layout, 400, 400);
        stage.setScene(scene);
        stage.show();
    }
}
package com.esame;
public class PlayerController {
    private PlayerModel model;
    private EntityView view;
    public PlayerController(PlayerModel model, int avatar) {
        this.model = model;
        this.view = new EntityView("bomberman", true, 3, avatar - 1);
        model.addListener(view);
    }
    public void input(String directionString) {
        if (directionString != null) {
            model.startMoving(directionString);
        } else {
            model.stopMoving();
        }
    }
    public PlayerModel getModel() {
        return model;
    }
    public EntityView getView() {
        return view;
    }
    public void updateState(double elapsed) {
        model.updateState(elapsed);
    }
}
package com.esame;
public class PlayerData {
    private String nickname;
    private String avatar;
    private String lastLevel;
    private String playedGames;
    private String winGames;
    private String lostGames;
    private String score;
    public PlayerData(String nickname, String avatar, String lastLevel, String playedGames, String winGames, String lostGames, String score) {
        this.nickname = nickname;
        this.avatar = avatar;
        this.lastLevel = lastLevel;
        this.playedGames = playedGames;
        this.winGames = winGames;
        this.lostGames = lostGames;
        this.score = score;
    }
    public String getNickname() {
        return nickname;
    }
    public void setNickname(String nickname) {
        this.nickname = nickname;
    }
    public String getAvatar() {
        return avatar;
    }
    public void setAvatar(String avatar) {
        this.avatar = avatar;
    }
    public String getLastLevel() {
        return lastLevel;
    }
    public int getLastLevelInt() {
        return Integer.parseInt(lastLevel);
    }
    public void setLastLevel(int lastLevel) {
        this.lastLevel = Integer.toString(lastLevel);
    }
    public String getPlayedGames() {
        return playedGames;
    }
    public int getPlayedGamesInt() {
        return Integer.parseInt(playedGames);
    }
    public void setPlayedGames(int playedGames) {
        this.playedGames = Integer.toString(playedGames);
    }
    public void setWinGames(int winGames) {
        this.winGames = Integer.toString(winGames);
    }
    public int getWinGamesInt() {
        return Integer.parseInt(winGames);
    }
    public String getWinGames() {
        return winGames;
    }
    public void setWinGames(String winGames) {
        this.winGames = winGames;
    }
    public String getLostGames() {
        return lostGames;
    }
    public int getLostGamesInt() {
        return Integer.parseInt(lostGames);
    }
    public void setLostGames(int lostGames) {
        this.lostGames = Integer.toString(lostGames);
    }
    public String getScore() {
        return score;
    }
    public void setScore(int newScore) {
        int currentScore = Integer.parseInt(getScore());
        if (currentScore < newScore) {
            this.score = Integer.toString(newScore);
        }
    }
    public String getDataString() {
        return nickname + "," + avatar + "," + lastLevel + "," + playedGames + "," + winGames + "," + lostGames + "," + score;
    }
}
package com.esame;
import javafx.beans.property.IntegerProperty;
import javafx.beans.property.SimpleIntegerProperty;
public class PlayerModel extends EntityModel {
    private final IntegerProperty score = new SimpleIntegerProperty(0);
    private final IntegerProperty bombCapacity = new SimpleIntegerProperty(1); 
    private final IntegerProperty bombRadius = new SimpleIntegerProperty(1);
    private boolean justLostLife = false;
    private boolean justGainedPowerUp = false;
    private int recoveryTime = 20;
    private boolean recovering = false;
    public PlayerModel(int initialX, int initialY, StageModel stage) {
        super(initialX, initialY, new int[] {13, 13}, new int[] {7, 17}, 3, stage);
        // Set default values for lives and score or any additional setup.
        this.score.set(0); // Initial score
    }
    public IntegerProperty lifeProperty() {
        return this.life;
    }
    @Override
    public void loseLife(int amount) {
        loseLife();
    }
    public void loseLife() {
        if (this.recovering) return;
        this.life.set(getLife() - 1);
        if (isDead()) {
            clearOccupiedTiles();
        }
        this.recovering = true;
        justLostLife = true;
        notifyListeners();
    }
    public boolean justLostLife() {
        if (justLostLife) {
            justLostLife = false;
            return true;
        }
        return false;
    }
    @Override
    public EntityModel checkCollision(int dx, int dy) {
        EntityModel occupant = super.checkCollision(dx, dy);
        if (occupant instanceof EnemyModel) {
            loseLife(1);
        }
        notifyListeners();
        return occupant;
    }
    
    public IntegerProperty scoreProperty() {
        return this.score;
    }
    public int getScore() {
        return this.score.get();
    }
    public IntegerProperty bombCapacityProperty() {
        return this.bombCapacity;
    }
    public int getBombCapacity() {
        return this.bombCapacity.get();
    }
    public void increaseBombCapacity() {
        this.bombCapacity.set(this.bombCapacity.get() + 1);
        justGainedPowerUp = true;
        notifyListeners();
    }
    public IntegerProperty bombRadiusProperty() {
        return this.bombRadius;
    }
    public int getBombRadius() {
        return this.bombRadius.get();
    }
    public void increaseBombRadius() {
        this.bombRadius.set(this.bombRadius.get() + 1);
        justGainedPowerUp = true;
        notifyListeners();
    }
    public void increaseSpeed() {
        // this.velocity.set(this.velocity.get() + 0.3);
        if (this.delayMove > 0.01) this.delayMove -= 0.01;
        justGainedPowerUp = true;
        notifyListeners();
    }
    public boolean justGainedPowerUp() {
        if (justGainedPowerUp) {
            justGainedPowerUp = false;
            return true;
        }
        return false;
    }
    public void addScore(int points) {
        this.score.set(this.score.get() + points);  
        notifyListeners();
    }
    public boolean isOnNextLevelDoor() {
        for (EmptyTile tile : occupiedTiles) {
            if (tile instanceof SpecialTile && ((SpecialTile) tile).getType() == SpecialTileType.nextLevelDoor) {
                return true;
            }
        }
        return false;
    }
    @Override
    public void updateState(double elapsedTime) {
        super.updateState(elapsedTime);
        if (this.recovering) {
            this.recoveryTime--;
            if (this.recoveryTime == 0) {
                this.recovering = false;
                this.recoveryTime = 20;
            }
        }
    }
    
}
package com.esame;
import javafx.beans.Observable;
public class PlayerSound implements EntityStateObserver {
    private int audioDelay = 120;
    @Override
    public void invalidated(Observable observable) {
        AudioUtils.stopAll();      
    }
    @Override
    public void update(EntityModel playerEntityModel) {
        PlayerModel playerModel = (PlayerModel) playerEntityModel; // fai il casting dell'entità a PlayerModel
        if (playerModel.justLostLife()) { // Assume this method exists and tracks if a life was recently lost
            AudioUtils.playSoundEffect("LoseLife.mp3");
        }
        if (playerModel.justGainedPowerUp()) { // Similarly, assume this checks for recent power-up acquisition
            AudioUtils.playSoundEffect("ItemGet.mp3");
        }
        if (playerModel.isMoving()) {
            audioDelay -= 1;
            if (audioDelay <= 0) {
                AudioUtils.playSoundEffect("Walking.mp3");
                audioDelay = 120;
            }
        }
    }
}
package com.esame;
public class PowerUp extends SpecialTile{
    /*
     * Se il power-up è stato applicato.
    private boolean applied = false;
    /*
     * Il comportamento del power-up.
    private PowerUpBehaviour behaviour;
    public PowerUp(int x, int y, SpecialTileType type) {
        super(x, y, type);
        if (type == SpecialTileType.pupBlast) {
            this.behaviour = new PowerUpBlast();
        }
        else if (type == SpecialTileType.pupBomb) {
            this.behaviour = new PowerUpBomb();
        }
        else if (type == SpecialTileType.pupSpeed) {
            this.behaviour = new PowerUpSpeed();
        }
    }
    @Override
    public void setOccupant(EntityModel occupant) {
        super.setOccupant(occupant);
        if (applied) return;
        if (occupant instanceof PlayerModel) {
            applyPowerUp((PlayerModel) occupant);
        }
        setDisplayable(false);
        applied = true;
    }
    @Override
    public boolean isDetonable() {
        if (!applied) return true; // Il power-up può essere detonato se non è stato applicato
        return super.isDetonable(); // Il power-up è stato applicato, quindi si comporta come una casella vuota normale
    }
    public void applyPowerUp(PlayerModel playerModel) {
        behaviour.applyPowerUp(playerModel);
    };
}
package com.esame;
public interface PowerUpBehaviour {
    void applyPowerUp(PlayerModel playerModel);
}package com.esame;
public class PowerUpBlast implements PowerUpBehaviour{
    @Override
    public void applyPowerUp(PlayerModel playerModel){
        playerModel.increaseBombRadius();
    }
}
package com.esame;
public class PowerUpBomb implements PowerUpBehaviour{
    
    @Override
    public void applyPowerUp(PlayerModel playerModel){
        playerModel.increaseBombCapacity();
    }
}
package com.esame;
public class PowerUpSpeed implements PowerUpBehaviour{
    
    @Override
    public void applyPowerUp(PlayerModel playerModel){
        playerModel.increaseSpeed();
    }
}
package com.esame;
public class SpecialTile extends EmptyTile{
    protected SpecialTileType type;
    public SpecialTile(int x, int y, SpecialTileType type) {
        super(x, y);
        setType(type);
        setDisplayable(true);
    }
    public SpecialTileType getType() {
        return type;
    }
    public void setType(SpecialTileType type) {
        this.type = type;
    }
}
package com.esame;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Random;
enum SpecialTileType {
  pupBlast,
  pupBomb,
  pupSpeed,
  nextLevelDoor;
  public static SpecialTileType getRandomPowerUpType() {
      // Convert array to a modifiable list
      List<SpecialTileType> values = new ArrayList<>(Arrays.asList(values()));
      values.remove(SpecialTileType.nextLevelDoor); // Now this operation is supported
      int size = values.size();
      Random random = new Random();
      return values.get(random.nextInt(size));
  }
}package com.esame;
import java.util.ArrayList;
import java.util.List;
import javafx.beans.Observable;
import javafx.beans.InvalidationListener;
import java.util.Random;
public class StageModel implements Observable {
    private List<StageObserver> observers = new ArrayList<>();
    private final int width = 17;
    private final int height = 13;
    private double powerUpProbability = 0.8; // 80% chance of adding a PowerUp tile
    private final int tileSize = 16; // Assuming each tile is 16x16 pixels
    final int freeSlots = 110; // Number of free slots in the stage
    private final int destructibleTilesStart;
    private int destructedTiles = 0;
    private final List<int[]> freeTileIndex = new ArrayList<>();
    private Tile[][] tiles = new Tile[width][height];
    private Random rand = new Random();
    private PlayerModel player;
    private int damage = 100;
    private SpecialTile nextLevelDoor;
    
    public StageModel() {
        this(0.2, 0.04); // Default destructible and non-destructible percentages
    }
    public StageModel(double destructiblePercentage, double nonDestructiblePercentage) {
        // Calculate the total number of free positions
        int destructibleTilesCount = (int) (freeSlots * destructiblePercentage);
        destructibleTilesStart = destructibleTilesCount;
        int nonDestructibleTilesCount = (int) ((freeSlots-destructibleTilesCount) * nonDestructiblePercentage);
        // Fill the stage with non-walkable borders and predefined tiles
        for (int x = 0; x < width; x++) {
            for (int y = 0; y < height; y++) {
                if (x < 2 || x > width - 3 || y == 0 || y == height - 1 || (x % 2 == 1 && y % 2 == 0)) {
                    tiles[x][y] = new Tile(x * tileSize, y * tileSize, false, false); // Non-destructible and not displayable
                }
            }
        }
        // lascia la posizione in alto a sinsitra per il giocatore
        tiles[2][1] = new EmptyTile(2, 1);
        tiles[2][2] = new EmptyTile(2, 2);
        tiles[3][1] = new EmptyTile(3, 1);
        for (int x = 2; x < width - 2; x++) {
            for (int y = 1; y < height - 1; y++) {
                // lascia le posizioni nell'angolo in alto a sinistra libere per far muovere il giocatore
                if (tiles[x][y] == null && !(x == 2 && y == 1) && !(x == 2 && y == 2) && !(x == 3 && y == 1)) {
                    freeTileIndex.add(new int[] {x, y});
                }   
            }
        }
    
        // Randomly place destructible and non-destructible tiles
        for (int i = 0; i < destructibleTilesCount; i++) {
            int[] position = freeTileIndex.remove(rand.nextInt(freeTileIndex.size()));
            tiles[position[0]][position[1]] = new Tile(position[0] * tileSize, position[1] * tileSize, true);
        }
        for (int i = 0; i < nonDestructibleTilesCount; i++) {
            int[] position = freeTileIndex.remove(rand.nextInt(freeTileIndex.size()));
            tiles[position[0]][position[1]] = new Tile(position[0] * tileSize, position[1] * tileSize, false);
        }
        // in all the other freeTileIndex, add empty tiles
        for (int[] position : freeTileIndex) {
            tiles[position[0]][position[1]] = new EmptyTile(position[0], position[1]);
        }
    }
    public void setPlayer(PlayerModel player) {
        this.player = player;
    }
    public Tile getTile(int x, int y) {
        if (x >= 0 && x < width && y >= 0 && y < height) {
            return tiles[x][y];
        }
        return null; // Out of bounds
    }
    public EmptyTile getEmptyTile(int x, int y) {
        if (x >= 0 && x < width && y >= 0 && y < height) {
            if (tiles[x][y] instanceof EmptyTile)
            return (EmptyTile) tiles[x][y];
        }
        return new EmptyTile(x, y); // return a dummy empty tile
    }
    public Tile getTileAtPosition(int x, int y) {
        int tileX = (int) (x / tileSize);
        int tileY = (int) (y / tileSize);
        return getTile(tileX, tileY);
    }
    public EmptyTile getEmptyTileAtPosition(int x, int y) {
        int tileX = (int) (x / tileSize);
        int tileY = (int) (y / tileSize);
        return getEmptyTile(tileX, tileY);
    }
    public List<int[]> getFreeTileIndex() {
        return freeTileIndex;
    }
    public SpecialTile getNextLevelDoor() {
        return nextLevelDoor;
    }
    public void setTile(int x, int y, Tile tile) {
        if (x >= 0 && x < width && y >= 0 && y < height) {
            tiles[x][y] = tile;
        }
    }
    public void setTileAtPosition(int x, int y, Tile tile) {
        int tileX = (int) (x / tileSize);
        int tileY = (int) (y / tileSize);
        setTile(tileX, tileY, tile);
    }
    public BombModel getBombAtPosition(int x, int y) {
        int tileX = (int) (x / tileSize);
        int tileY = (int) (y / tileSize);
        if (getTile(tileX, tileY) instanceof BombModel) {
            return (BombModel) getTile(tileX, tileY);
        }
        return null;
    }
    public int[] getTileStartCoordinates(int x, int y) {
        int tileX = (int) (x / tileSize);
        int tileY = (int) (y / tileSize);
        return new int[] {tileX * tileSize, tileY * tileSize};
    }
    public boolean isBorder(int x, int y) {
        return x < 2 * tileSize || x >= (width - 3) * tileSize || y < tileSize || y >= (height - 2) * tileSize;
    }
    public boolean destroyTile(int x, int y) {
        if (x >= 0 && x < width && y >= 0 && y < height && tiles[x][y] != null) {
            // the tile is not destructible
            if (!tiles[x][y].isDestructible()) return true;
            // the tile is empty but occupied
            if ((tiles[x][y] instanceof EmptyTile) && ((EmptyTile) tiles[x][y]).isOccupied()) {
                EmptyTile occupiedTile = (EmptyTile) tiles[x][y];
                EntityModel occupant = occupiedTile.getOccupant();
                occupant.loseLife(damage);
                if (tiles[x][y] instanceof BombModel) {
                    setTile(x, y, new EmptyTile(x, y));
                    ((EmptyTile) tiles[x][y]).setOccupant(occupant);
                }
                if (player != null && !(occupant instanceof PlayerModel)) {
                    player.addScore(damage);
                }
            }
            // the tile is a special tile (but not a next level door)
            else if (tiles[x][y] instanceof PowerUp) {
                setTile(x, y, new EmptyTile(x, y));
            }
            // the tiles is destructible tile, in case add powerup or next level door
            else if (!(tiles[x][y] instanceof EmptyTile)){
                double nextLevelDoorProbability = (double) destructedTiles / destructibleTilesStart;
                if (this.nextLevelDoor == null && rand.nextDouble() < nextLevelDoorProbability) {
                        setTile(x, y, new SpecialTile(x, y, SpecialTileType.nextLevelDoor)); // Create a new instance of NextLevelDoor
                        this.nextLevelDoor = (SpecialTile) tiles[x][y];
                } 
                else if (rand.nextDouble() < powerUpProbability) {
                    setTile(x, y, new PowerUp(x, y, SpecialTileType.getRandomPowerUpType())); // Create a new instance of PowerUp
                }
                else setTile(x, y, new EmptyTile(x, y));
                destructedTiles++;
            }
            // the tile was simply empty
            else {
                setTile(x, y, new EmptyTile(x, y));
            }
            freeTileIndex.add(new int[] {x, y});
            // tile destroyed
            return true;
        }
        // tile out of bounds
        return false;
    }
    public boolean destroyTileAtPosition(int x, int y) {
        int tileX = (int) (x / tileSize);
        int tileY = (int) (y / tileSize);
        return destroyTile(tileX, tileY);
    }
    public boolean canExplodeAtPosition(int x, int y) {
        Tile tile = getTileAtPosition(x, y);
        return tile == null || tile.isDestructible();
    }
    public boolean addBombAtPosition(int x, int y, int bombRadius) {
        int tileX = (int) (x / tileSize);
        int tileY = (int) (y / tileSize);
        Tile tile = tiles[tileX][tileY];
        if (!(tile instanceof EmptyTile) || tile instanceof BombModel || tile == this.nextLevelDoor) {
            return false;
        }
        EntityModel previousOccupant = ((EmptyTile) tiles[tileX][tileY]).getOccupant();
        tiles[tileX][tileY] = new BombModel(tileX * tileSize, tileY * tileSize, bombRadius);
        ((EmptyTile) tiles[tileX][tileY]).setOccupant(previousOccupant);
        return true;
    }
    
    public int getTileSize() {
        return tileSize;
    }
    public int getWidth() {
        return width;
    }
    public int getHeight() {
        return height;
    }
    public int[] getRandomFreeTile() {
        if (freeTileIndex.isEmpty()) {
            return null; // No more free tiles available
        }
        int randomIndex = rand.nextInt(freeTileIndex.size());
        return freeTileIndex.remove(randomIndex);
    }
    public void addListener(InvalidationListener listener) {
        observers.add((StageObserver) listener);
    }
    public void removeListener(InvalidationListener listener) {
        observers.remove((StageObserver) listener);
    }
    public void notifyListeners() {
        observers.forEach(observer -> observer.update(this));
    }
}
package com.esame;
import javafx.beans.InvalidationListener;
public interface StageObserver extends InvalidationListener{
    
    void update(StageModel stageModel);
}
package com.esame;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.image.PixelReader;
import javafx.scene.image.PixelWriter;
import javafx.scene.image.WritableImage;
import javafx.scene.layout.Pane;
public class StageView implements StageObserver {
    private Pane pane = new Pane(); // Pannello per contenere il palco e le caselle
    private Image stageImage; // Immagine di sfondo del palco
    private Image tilesImage; // Immagine contenente le sprite delle caselle
    private ImageView combinedView;
    public StageView(int levelNumber) {
        // Carica le immagini del palco e delle caselle in base al numero di livello
        stageImage = new Image(getClass().getResourceAsStream("/sprites/level" + levelNumber + "_stage.png"));
        tilesImage = new Image(getClass().getResourceAsStream("/sprites/level" + levelNumber + "_tiles.png"));
        combinedView = new ImageView();
        pane.getChildren().add(combinedView); // Aggiunge la vista combinata all'interno del pannello
    }
    @Override
    public void update(StageModel stage) {
        int tileSize = stage.getTileSize();
        int width = stage.getWidth() * tileSize;
        int height = stage.getHeight() * tileSize;
        WritableImage combinedImage = new WritableImage(width, height);
        PixelWriter writer = combinedImage.getPixelWriter();
        // Copia lo sfondo del palco nell'immagine combinata
        PixelReader stageReader = stageImage.getPixelReader();
        writer.setPixels(0, 0, width, height, stageReader, 0, 0);
        // Itera sulle caselle e le aggiunge all'immagine combinata
        PixelReader tilesReader = tilesImage.getPixelReader();
        for (int x = 0; x < stage.getWidth(); x++) {
            for (int y = 0; y < stage.getHeight(); y++) {
                Tile tile = stage.getTile(x, y);
                if (tile.isDisplayable()) {
                    if (tile instanceof SpecialTile) {
                        PixelReader powerUpReader = new Image(getClass().getResourceAsStream("/sprites/" + ((SpecialTile) tile).getType().toString() + ".png")).getPixelReader();
                        writer.setPixels(x * tileSize, y * tileSize, tileSize, tileSize, powerUpReader, 0, 0);
                    }
                    else {
                        int srcX = tile.isDestructible() ? 16 : 0;
                        writer.setPixels(x * tileSize, y * tileSize, tileSize, tileSize, tilesReader, srcX, 0);
                    }
                }
                else if (tile instanceof EmptyTile && !stage.getTile(x, y - 1).isDestructible()){
                    // Se la casella non è visualizzabile, ma la casella sopra di essa non è distruttibile, visualizza la casella ombra
                    writer.setPixels(x * tileSize, y * tileSize, tileSize, tileSize, tilesReader, 32, 0);
                }
            }
        }
        combinedView.setImage(combinedImage);
    }
    public Pane getPane() {
        return pane;
    }
    public void invalidated(javafx.beans.Observable observable) {
        pane.getChildren().remove(combinedView);
    }
}
package com.esame;
public class Tile extends XYModel{
    protected boolean isDestructible;
    protected boolean isDisplayable = true;
    protected boolean isWalkable = false;
    public Tile(int x, int y, boolean isDestructible) {
        super(x, y);
        this.isDestructible = isDestructible;
    }
    public Tile(int x, int y, boolean isDestructible, boolean isDisplayable) {
        super(x, y);
        this.isDestructible = isDestructible;
        this.isDisplayable = isDisplayable;
    }
    public Tile(int x, int y, boolean isDestructible, boolean isDisplayable, boolean isWalkable) {
        super(x, y);
        this.isDestructible = isDestructible;
        this.isDisplayable = isDisplayable;
        this.isWalkable = isWalkable;
    }
    public boolean isDestructible() {
        return isDestructible;
    }
    public boolean isWalkable() {
        return isWalkable;
    }
    public boolean isDetonable() {
        return isDestructible && isDisplayable;
    }
    public void setWalkable(boolean walkable) {
        isWalkable = walkable;
    }
    public boolean isDisplayable() {
        return isDisplayable;
    }
    public void setDisplayable(boolean displayable) {
        isDisplayable = displayable;
    }
}
package com.esame;
import javafx.beans.property.IntegerProperty;
import javafx.beans.property.SimpleIntegerProperty;
public abstract class XYModel {
    protected final IntegerProperty x = new SimpleIntegerProperty();
    protected final IntegerProperty y = new SimpleIntegerProperty();
    public XYModel() {
        this(0, 0);
    }
    public XYModel(int x, int y) {
        this.x.set(x);
        this.y.set(y);
    }
    public IntegerProperty xProperty() {
        return x;
    }
    public IntegerProperty yProperty() {
        return y;
    }
    public int getX() {
        return x.get();
    }
    public int getY() {
        return y.get();
    }
    public void setX(int x) {
        this.x.set(x);
    }
    public void setY(int y) {
        this.y.set(y);
    }
    public void setPosition(int x, int y) {
        this.x.set(x);
        this.y.set(y);
    }
}